./ : gtest-origin/googletest/ gtest-origin/googlemock/
# Previous line: building this directory means building these directories
# (see below)

# We try to follow the setup defined by the CMake files from gtest repository.

### Questions for Build2 Authors ######
#
# 1. Is there a way to create aliases for names/targets?
#    That would help define targets in sub-scopes, then alias them in higher scopes.
#
# 2. What is the difference between += and =+ ?
#
# 3. Why is "somedir/ : somedir/*" used when "somedir/" does not have a buildfile?
#    Isn't it inconsistent with the behaviour of build2 when doing "b" in a directory?
#
# 4. Why is
#      cxx.poptions =+ "-I$include_dir"
#    working but not
#      lib{lib_a, lib_b}: cxx.poptions =+ "-I$include_dir"
#     ?
#
# 5. When converting a library to build2, I often have to use a submodule with the real sources.
#    Could you make bdep detect that we use paths from the submodule in buildfile and automatically
#    update/init the submodule?
#
# 6. Same context: Having the submodule next to the buildfile can result in this kind of situation (gtest for example):
#
#      ./buildfile
#      ./src_base/real_repo/projectname/include/projectname/projectname.hpp
#      ./src_base/real_repo/projectname/include/projectname/submodule.hpp
#      ./src_base/real_repo/projectname/include/projectname/detail/xxxmodule.hpp
#      ./src_base/real_repo/projectname/include/projectname/detail/util/dontlookatme.hpp
#
#    Default install will put them all in install.root/include
#      ./include/projectname.hpp
#      ./include/submodule.hpp
#      ./include/xxxmodule.hpp
#      ./include/dontlookatme.hpp
#
#    I tried install.subdirs = true but I ended up with:
#      ./include/real_repo/projectname/include/projectname/projectname.hpp
#      ./include/real_repo/projectname/include/projectname/submodule.hpp
#      ./include/real_repo/projectname/include/projectname/detail/xxxmodule.hpp
#      ./include/real_repo/projectname/include/projectname/detail/util/dontlookatme.hpp
#
#    Is there another variable allowing to specify the directory in the path that should be the root in the mirrored install path?
#    That is, what do I need to do to obtain the following?
#
#      ./include/projectname/projectname.hpp
#      ./include/projectname/submodule.hpp
#      ./include/projectname/detail/xxxmodule.hpp
#      ./include/projectname/detail/util/dontlookatme.hpp
#
#    (So that it matches the expected install of the original build scripts)
#
# 7. It is surprising that this works (example inspired by cargo, as pointed by some people I discussed with):
#        bdep new anyproject
#        cd anyproject
#        b
#    But this does not work:
#        bdep new anyproject
#        cd anyproject
#        bdep update
#    It is a similar surprising weirdness that `b install` have no equivalent in bdep.
#
# 8. When a dependency package exists in the configuration being built but do not have a compatible version,
#    the report is not clear at all that this is the source of the issue and say
#       error: unknown dependency gtest ^1.8.0 of package libexample
#       info: repository E:\Projects\build2-libs\libexample appears to be broken
#       info: or the repository state could be stale
#    which is all incorrect. First, it might just be that the dependency is missing.
#    Second, if the dependency is not missing but don't have a compatible version, that's what should be reported,
#    with the dependency version currently available for this configuration.
#    Maybe it only happens with '-' versions?
#
# 9. Request: add ways to manipulate strings (to forge name of targets)
#    What is missing here: a way to remove something from a name (see samples below).
#
# 10. It is not clear to me how to variable trees to be stored in configuration.
#     I can persist the config.* values that already exist or that are specified in CLI (using configure).
#     I can use variables specified from CLI.
#     I don't seem to be able to test a variable that should not exist in a tree by default.
#     I can't persist variables that are not config.* (using configure)
#
# 11. Knowing which link error report comes from which linking command is almost impossible.
#     I think I already pointed this: logs from processes specific to a project could be marked
#     so that even when launched in parallel we can follow what is happening.
#

# NOTE FOR THE READER: jumping into directories (opening scopes) is not usual,
# I do it here mainly to define the targets close to where all their sources are.
# NOTE ABOUT gtest_main: I had to not make it a target but just a variable to use as dependency
# because the linking step reports a missing entry point when using it. Not sure why yet.

## GTEST #############

gtest-origin/googletest/ # Jump into this directory
{
  ./ : lib{gtest} liba{gtest_main}

  # gtest : Google Test library to use in your tests.
  lib{gtest} : src/cxx{gtest-all} include/hxx{**}
  # Makes sure the include directory is accessible to user code.
  lib{gtest} : cxx.export.poptions += "-I$src_base/include"

  # gtest_main : library defining a main() so that you don't have to duplicate it in each program
  liba{gtest_main} : src/cxx{gtest_main} lib{gtest}  # We only support it as a static library.
  liba{gtest_main} : bin.whole = true # Do not remove the main() implementation because it is not directly used.
  # liba{gtest_main} : cxx.export.libs = lib{gtest} # TODO: does not work as expected - WHY? scoping issue?

  # All targets here need to have these directories accessible for including.
  cxx.poptions =+ "-I$src_base/include" "-I$src_base/src" "-I$src_base"

  # DLL import/export symbol macros have to be activated/deactivated depending
  # on if you are building the dynamic library or linking with it.
  # Of course these special defines exists only if you use dynamic libraries.
  objs{*}: cxx.poptions        += -DGTEST_CREATE_SHARED_LIBRARY
  libs{*}: cxx.export.poptions += -DGTEST_LINKED_AS_SHARED_LIBRARY

  # Make sure the public headers are installed.
  hxx{*}: install         = include/gtest/
  hxx{*}: install.subdirs = true

  #############################################################
  # Samples on how to link user tests with gtest or gtest_main.
  gtest_build_samples = false # By default we don't build them.
  if $gtest_build_samples
  {
    ./ : samples/ # Build all sample executables that we can define below.

    info "GTEST: BUILDING SAMPLES"
    samples/ # For simplicity of naming.
    {
      cxx.poptions =+ "-I$src_base" # Makes samples directory headers available.

      # Each sample starts with a *_unittest.cc file.
      for sample: cxx{*_unittest}
      {
        sample_name = $name($sample)
        sample_prefix = $sample_name # TODO: make it better once I have a way to operate strings (see below)

        info "GTEST SAMPLE: $sample_name \($sample_prefix\)"

        # Some samples have more than one .cc file, but they all start with the same name.
        exe{$sample_name}: {cxx}{$sample_prefix}

        ./ : exe{$sample_name} # Make sure this sample will be built.

      }

      # Almost all samples use gtest_main to define main().
      # exe{* -sample9_unittest -sample10_unittest}: ../liba{gtest_main} # DO NOT WORK
      exe{sample1_unittest}: ../liba{gtest_main}
      exe{sample2_unittest}: ../liba{gtest_main}
      exe{sample3_unittest}: ../liba{gtest_main}
      exe{sample4_unittest}: ../liba{gtest_main}
      exe{sample5_unittest}: ../liba{gtest_main}
      exe{sample6_unittest}: ../liba{gtest_main}
      exe{sample7_unittest}: ../liba{gtest_main}
      exe{sample8_unittest}: ../liba{gtest_main}
      exe{sample9_unittest sample10_unittest}    : ../lib{gtest} # DOES WORK

      # TODO: use target blocks once supported
      # exe{*}: # Set configuration to all executables defined here.
      # {
      #   dist = true
      #   install = samples/    # Install them in this directory.
      # }
      exe{*}: dist = true
      exe{*}: install = samples/ # Install them in this directory.
      exe{*}: test = true # We want to run these samples when testing.

      # TODO: if I had some way to remove the suffix "_unittest" from the sample name,
      # the sample_prefix would have just the rigth name to glob
      # and automatically match the files being listed in the CMakeLists.txt file.
      # Meanwhile I have to add them manually like in the CMakeLists.txt file ...
      exe{sample1_unittest} : cxx{sample1}
      exe{sample2_unittest} : cxx{sample2}
      exe{sample4_unittest} : cxx{sample4}
      exe{sample5_unittest} : cxx{sample1} # I think it's an error in the original CMakeLists.txt

    }

  }

  #############################################################
  # Google Test's own tests.
  gtest_build_tests = false # By default we don't build them.
  if $gtest_build_tests
  {

  }

}

## GMOCK #############

gtest-origin/googlemock/ # Jump into this directory
{
  ./ : # ...
}